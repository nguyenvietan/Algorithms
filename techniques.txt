					*TECHNICAL SKILLS to REMEMBER*

List all combinations

Java Heap, Comparator, ...
------------------------
Java's key libraries

Sorting:
	Arrays.sort(int[]) // more? 


Maps:
	containsKey()
	keySet()
	putIfAbsent(key, val)
		eg.	map.putIfAbsent(arr[i], new ArrayList<>());
            map.get(arr[i]).add(i);
Lists:
	addAll(List<>)
	add(int)
	remove(list.size()-1)
	List<List<Integer>> list; list.add(new ArrayList<>(list2));
	list to array: list.toArray(new int[list.size][])

Queue:
	Queue<Integer> q = new LinkedList<>();
	q.isEmpty(), q.poll(), q.add()

Priority Queues:
    // dist
    int[] dist = new int[n];
    Arrays.fill(dist, oo);
    // pq
    PriorityQueue<int[]> pq = new PriorityQueue<>((u, v) -> (u[1] - v[1])); // (v, weight)
    pq.add(new int[]{0, dist[0] = 0});
    pq.add(new int[]{firstPerson, dist[firstPerson] = 0});

Dequeue (faster than LinkedList/Stack as a queue)
	Deque<Character> dq = new ArrayDeque<>();
	+ methods: add()/addLast(), addFirst(), poll()/removeFirst(), removeLast()
	+ iteration:
		Iterator it = dq.descendingIterator();
		// or: Iterator it = dq.iterator();
		while (it.hasNext()) {
			Character ch = (Character) it.next();

		}
#Techniques to remember

BIT MANIPULATION
	Count the number of bit 1s of an integer
		int count1bits(int x) {
			int cnt = 0;
			while (x > 0) {
				if ((x&1) != 0) cnt++;
				x >>= 1;
			}
			return cnt;
		}

	Or better way:
		int count1bits(int x) {
			int cnt = 0;
			while (x != 0) {
				cnt++;
				x = x & (x-1);
			}
			return cnt;
		}

LOWER BOUND, UPPER BOUND of an sorted array
	lower bound: return the index of the first num >= value
	upper bound: return the index of the first num > value
		0 1 2 3 4 5 5 5 5 7 8 9
				  ^       ^
				  lower   upper

	int lowerBound(int[] a, int val) {
		int	l = 0, r = a.length, m;
		while (l < r) {
			m = (l+r)/2;
			if (a[m] < val) l = m+1;
			else r = m;			
		}
		return r;
	}

	int upperBound(int[] a, int val) {
		int	l = 0, r = a.length, m;
		while (l < r) {
			m = (l+r)/2;
			if (a[m] <= val) l = m+1; // key difference
			else r = m;
		}
		return r;
	}

<<<<<<< HEAD
QUICK SELECT
	// TODO: review

==================================================
			FUNDAMENTAL DATASTRUCTURES
=======
PRIME DECOMPOSE
	List<Integer> primeDecompose(int n) {
		List<Integer> res = new ArrayList<>();
		int factor = 2;
		while (n >= factor*factor) {
			if (n%factor == 0) {
				res.add(factor);
				n /= factor;
			} else factor++;
		}
		res.add(num); // don't forget
		return res;				
	}
	Exercises:
		+ Largest Component Size by Common Factor	

# Basic data structures
>>>>>>> b90afbf60842cc12307986efb05d9e99f734d707

+ Disjoint Set Union

+ Priority Queue (Java)

+ Binary Search Tree
